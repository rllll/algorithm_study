# 数据结构

### 排序和查找

* [选择排序](selectSort.cpp)

    **算法思想**：从数组\[0..n-1\]中选择一个最小的数放在第一个位置，再从剩下的\[1..n-1\]个元素的子数组中选择最小的数放在第二个位置，重复进行n-1步后，算法结束。

    时间效率：O(n^2)

* [冒泡排序](BubbleSort.cpp)

    **算法思想**：比较数组中相邻的两个元素，如果逆序，则交换它们的位置，重复多次以后，数组中较大的元素总是向着数组末尾“沉”去，数组中较小的元素向首部“浮”去，因此把这种算法叫做“冒泡排序”。

    时间效率：O(n^2)
* [插入排序](InsertSort.cpp)

    **算法思想**：将数组看成两个子数组，分别是已排序子数组和未排序子数组。初始时，已排序数组中只有第一个元素，未排序数组中是剩下的n-1个元素。依次将未排序数组中的元素插入到已排序数组中合适位置，重复n-1次完成。

    时间效率：O(n^2)

* [合并排序](Mergesort.cpp)

    **算法思想**：将一个数组一分为二，分别对每个子数组递归排序，然后再将两个排好序的子数组合并成一个有序数组。这里采用分而治之的思想，即只要得到所有子问题的解，最终的解可以通过这些子问题的解得到。

    最差输入效率：O(nlogn)
    
    平均时间效率：O(nlogn)
    
    最优输入效率：O(nlogn)

* [快速排序](Quicksort_HoarePatition.cpp)

    **算法思想**：快速排序的核心是对于数组中的某个元素k，经过合适的操作确定其在最终序列中的位置，通常也把k看成一个键，将比k小的元素放在k的左边，比k大的元素放在k的右边，这样k的最终位置就确定了。之所以把k看成键来对数组进行划分，主要是因为通过这样的处理之后，对于k两边的左右子数组来说，可以进行递归操作，降低时间复杂度。

    **划分方法** 快速排序的划分方法有很多种，即对于数组中k的选取。代码采用快速排序发明者的划分方法（霍尔划分），其实也很简单，即选取第一个元素作为键值k，从第二个元素开始比较，如果比k小，继续比较下一位，直到遇到大于等于k的元素。再从最后一个元素往前，如果比k大，也继续往前，直到遇到小于等于k的元素。

    此时会面临三种情况（假设此时两个下标i和j）：i < j，将a[i]和a[j]对调，继续i++,j--；i > j，说明此时划分结束了，将k的位置放在a[j]的位置；i = j，划分结束，k的位置一定在a[i]或a[j]处，综合后两种情况，直接将k与a[j]对换。

    最差输入效率：O(n^2)

    平均时间效率：O(nlogn)

    最优时间效率：O(nlogn)

    值得一提的是，快速排序对于已经排好序的数组来说竟然是最差输入，因为对于每一次划分来说，比键值小的或比键值大的都在一边，也就是说算法的效率从原来的分而治之两边的数组实际上变成了一边，因而效率退化为O(n^2)。尽管如此，快速排序不失为一种效率可观的排序算法。

    [另一个版本的快速排序](Quicksort_anotherVersion.cpp)

* [堆排序](Heapsort.cpp)

    **算法思想**：构建一个最小（大）堆，排序时每次取树根元素，再将树根和最后一片叶子交换后删掉，最后重新将堆调整成最小（大）堆。

    最差输入效率：O(nlogn)

    平均时间效率：O(nlogn)
    
    最优输入效率：O(nlogn)

* [排序算法的比较](CompareSort.cpp)  
     
     程序对插入排序 自顶向和自底向上的归并排序 快速排序 三路划分的快速排序在乱序 基本有序 基本逆序的情况的性能作出比较