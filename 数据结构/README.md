# 数据结构

## <span id="content">目录</span>

* [排序和查找](#sort_and_search)

    * [选择排序](#SelectSort)

    * [冒泡排序](#BubbleSort)

    * [插入排序](#InsertSort)

    * [合并排序](#MergeSort)

    * [快速排序](#QuickSort)
    
    * [堆排序](#Heapsort)

    * [一些排序算法的时间比较](#compare)

### <span id="sort_and_seacrch">排序和查找</span>

* [<span id="SelectSort">选择排序</span>](selectSort.cpp) \[ [目录](#content) \]

    **算法思想**：从数组\[0..n-1\]中选择一个最小的数放在第一个位置，再从剩下的\[1..n-1\]个元素的子数组中选择最小的数放在第二个位置，重复进行n-1步后，算法结束。

    时间效率：O(n^2)

* [<span id="BubbleSort">冒泡排序</span>](BubbleSort.cpp) \[ [目录](#content) \]

    **算法思想**：比较数组中相邻的两个元素，如果逆序，则交换它们的位置，重复多次以后，数组中较大的元素总是向着数组末尾“沉”去，数组中较小的元素向首部“浮”去，因此把这种算法叫做“冒泡排序”。

    时间效率：O(n^2)
* [<span id="InsertSort">插入排序</span>](InsertSort.cpp) \[ [目录](#content) \]

    **算法思想**：将数组看成两个子数组，分别是已排序子数组和未排序子数组。初始时，已排序数组中只有第一个元素，未排序数组中是剩下的n-1个元素。依次将未排序数组中的元素插入到已排序数组中合适位置，重复n-1次完成。

    时间效率：O(n^2)

* [<span id="MergeSort">合并排序</span>](Mergesort.cpp) \[ [目录](#content) \]

    **算法思想**：将一个数组一分为二，分别对每个子数组递归排序，然后再将两个排好序的子数组合并成一个有序数组。这里采用分而治之的思想，即只要得到所有子问题的解，最终的解可以通过这些子问题的解得到。

    最差输入效率：O(nlogn)
    
    平均时间效率：O(nlogn)
    
    最优输入效率：O(nlogn)

* [<span id="QuickSort">快速排序</span>](Quicksort_HoarePatition.cpp) \[ [目录](#content) \]

    **算法思想**：快速排序的核心是对于数组中的某个元素k，经过合适的操作确定其在最终序列中的位置，通常也把k看成一个键，将比k小的元素放在k的左边，比k大的元素放在k的右边，这样k的最终位置就确定了。之所以把k看成键来对数组进行划分，主要是因为通过这样的处理之后，对于k两边的左右子数组来说，可以进行递归操作，降低时间复杂度。

    **划分方法** 快速排序的划分方法有很多种，即对于数组中k的选取。代码采用快速排序发明者的划分方法（霍尔划分），其实也很简单，即选取第一个元素作为键值k，从第二个元素开始比较，如果比k小，继续比较下一位，直到遇到大于等于k的元素。再从最后一个元素往前，如果比k大，也继续往前，直到遇到小于等于k的元素。

    此时会面临三种情况（假设此时两个下标i和j）：i < j，将a[i]和a[j]对调，继续i++,j--；i > j，说明此时划分结束了，将k的位置放在a[j]的位置；i = j，划分结束，k的位置一定在a[i]或a[j]处，综合后两种情况，直接将k与a[j]对换。

    最差输入效率：O(n^2)

    平均时间效率：O(nlogn)

    最优时间效率：O(nlogn)

    值得一提的是，快速排序对于已经排好序的数组来说竟然是最差输入，因为对于每一次划分来说，比键值小的或比键值大的都在一边，也就是说算法的效率从原来的分而治之两边的数组实际上变成了一边，因而效率退化为O(n^2)。尽管如此，快速排序不失为一种效率可观的排序算法。

    [另一个版本的快速排序](Quicksort_anotherVersion.cpp)

* [<span id = "Heapsort">堆排序</span>](Heapsort.cpp) \[ [目录](#content) \]

    **算法思想**：构建一个最小（大）堆，排序时每次取树根元素，再将树根和最后一片叶子交换后删掉，最后重新将堆调整成最小（大）堆。

    最差输入效率：O(nlogn)

    平均时间效率：O(nlogn)
    
    最优输入效率：O(nlogn)

* [<span id="CountingSort">计数排序（桶排序）</span>](#)\[ [目录](#content) \]

    计数方法有两种，分别是比较计数排序和分布计数排序。下面进行详细的探讨：

    [比较计数排序](ComparisonCountingSort.cpp)

    **算法思想**：对于待排序的数组中每一个元素，计算数组中小于该元素的个数，并将结果存放在一个新数组中。新数组反映了元素在排好序的数组中的最终位置。根据新数组的值我们可以将原数组中的每一个元素都放到其最终位置，这样就实现了数组的排序。

    时间效率：O(n^2)

    [分布计数排序](DistributionCountingSort.cpp)

    **算法思想**：这种计数方法巧妙利用了计数排序算法中限定数组元素的取值范围是确定的。对于待排序数组中所有元素都来自特定范围的情况，我们可以统计特定范围中每一个元素的数量，并通过逐渐累积的方法得到特定范围中每一位元素的最终位置。

    **注意**：1.限定了元素的取值范围。2.元素是正整数。3.时间效率为O(n)，但除了只能在特殊情况下使用外，还牺牲了较多的空间。所以，尽管计数排序的时间效率是O(n)，但仍不被当作主流排序算法使用。

    这种计数方法也衍生出一个更加简洁的计数排序写法，在应用上还是后者居多。可以查看[源代码](CountingSort.cpp)。

* [<span id="compare">排序算法的比较</span>](CompareSort.cpp) \[ [目录](#content) \]
     
     程序对插入排序 自顶向和自底向上的归并排序 快速排序 三路划分的快速排序在乱序 基本有序 基本逆序的情况的性能作出比较